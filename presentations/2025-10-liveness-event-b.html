<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Ramiro Garay">
  <title>Modelando propiedades de liveness en Event-B</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    /* For using incremental without anyone noticing it's a list */
    .no-bullet {
      list-style-type: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/theme/simple.css" id="theme">
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Modelando propiedades de liveness en Event-B</h1>
  <p class="author">Ramiro Garay</p>
  <p class="date">Octubre, 2025</p>
</section>

<section>
<section id="antes-de-empezar" class="title-slide slide level1">
<h1>Antes de empezar…</h1>

</section>
<section id="sobre-mí" class="slide level2">
<h2>Sobre mí</h2>
<div class="columns">
<div class="column" style="width:25%;">
<figure>
<img data-src="../img/new_profile_cropped.png" alt="Ramiro Garay" />
<figcaption aria-hidden="true">Ramiro Garay</figcaption>
</figure>
</div><div class="column" style="width:75%;">
<ul>
<li class="fragment">Argentino, ex-estudiante de Ingeniería en
Informática de la UNL, Santa Fe (2017-2022)</li>
<li class="fragment">Desarrollador a medio tiempo para MLabs, una
consultora especializada en Blockchain (2022-)</li>
<li class="fragment">Estudiante avanzado de Licenciatura en Computación
(2025-)</li>
<li class="fragment">Actualmente becario PREXI en el LINS</li>
</ul>
</div>
</div>
</section>
<section id="agenda" class="slide level2">
<h2>Agenda</h2>
<ol type="1">
<li class="fragment">Introducción a propiedades de liveness</li>
<li class="fragment">Introducción al modelo <code>PingPong</code></li>
<li class="fragment">Formalizacion de una propiedad de liveness</li>
<li class="fragment"><strong>Verificación</strong> de propiedades de
liveness usando <em>model checking</em></li>
</ol>
</section></section>
<section>
<section id="propiedades-de-liveness-intro"
class="title-slide slide level1">
<h1>Propiedades de Liveness (Intro)</h1>

</section>
<section id="una-definición-informal" class="slide level2">
<h2>Una definición informal</h2>
<p>“Son aquellas propiedades que nos garantizan que el sistema
eventualmente va a hacer <strong>algo</strong>”</p>
<div class="fragment">
<p>Son fundamentales, ya que permiten representar ciertos
comportamientos dinámicos del sistema.</p>
</div>
</section>
<section id="ejemplo-ascensor-i" class="slide level2">
<h2>Ejemplo: ascensor (I)</h2>
<p>Un ascensor debe cumplir propiedades de safety. Por ejemplo:</p>
<div class="columns">
<div class="column" style="width:30%;">
<p><img data-src="../img/ascensor.jpg" /></p>
</div><div class="column" style="width:70%;">
<ul>
<li class="fragment">El ascensor <strong>nunca</strong> se mueve con la
puerta abierta</li>
<li class="fragment">El ascensor <strong>nunca</strong> cierra la puerta
cuando un usuario es detectado en el umbral</li>
</ul>
</div>
</div>
</section>
<section id="ejemplo-ascensor-ii" class="slide level2">
<h2>Ejemplo: ascensor (II)</h2>
<p>Pero también de liveness!</p>
<div class="columns">
<div class="column" style="width:30%;">
<p><img data-src="../img/ascensor.jpg" /></p>
</div><div class="column" style="width:70%;">
<ul>
<li class="fragment">Si el usuario pide el ascensor,
<strong>eventualmente</strong> el mismo viaja hacia el piso del
usuario.</li>
<li class="fragment">Si el usuario seleccionó un piso,
<strong>eventualmente</strong> el ascensor va a llegar al piso
pedido.</li>
</ul>
</div>
</div>
</section>
<section id="ejemplo-ascensor-iii" class="slide level2">
<h2>Ejemplo: ascensor (III)</h2>
<p>Un ascensor sin propiedades de liveness puede ser muy seguro, pero
también <strong>inútil</strong>.</p>
<div class="fragment">
<p><em>Ejemplo</em>: Un ascensor que se mantiene cerrado e inmóvil
satisface todas las propiedades de safety pero <strong>ninguna</strong>
de liveness.</p>
</div>
</section>
<section id="completitud-de-propiedades-de-safety-y-liveness"
class="slide level2">
<h2>“Completitud” de propiedades de <em>safety</em> y
<em>liveness</em></h2>
<aside class="notes">
<p>NOTA IMPORTANTE:</p>
<p>Una característica de las propiedades de safety es que, una vez
violadas, son irremediables (ej: una vez que el ascensor cerró la puerta
con un usuario entrando, es más que suficiente para decir que es
inseguro).</p>
<p>Las propiedades de liveness, en cambio, no. Porque solo aseguran que
algo ocurrirá eventualmente (ej: un ascensor puede tardar mucho en
venir, pero siempre que eventualmente lo haga, va a satisfacer la
propiedad de liveness).</p>
<p>Pregunta: ¿como logramos que el ascensor venga siempre, pero con un
limite de tiempo? RTA: Safety + Liveness</p>
</aside>
<ul>
<li class="fragment"><p>Usando propiedades de safety y liveness, uno
puede especificar <strong>completamente</strong> un sistema. <a
href="#/fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p></li>
<li class="fragment"><p>O al revés: toda propiedad es de safety,
liveness o una combinación de ambas.</p></li>
</ul>
</section>
<section id="ejemplos-de-propiedades-de-liveness" class="slide level2">
<h2>Ejemplos de propiedades de liveness</h2>
<aside class="notes">
<p>Algunos ejemplos reales y relevantes para computación
distribuida.</p>
</aside>
<ol type="1">
<li class="fragment"><em>Starvation freedom</em>: un proceso hace
progreso infinitamente seguido</li>
<li class="fragment"><em>Termination</em>: el proceso finaliza</li>
<li class="fragment"><em>Guaranteed service</em>: cada solicitud es
satisfecha eventualmente</li>
</ol>
</section></section>
<section>
<section id="introducción-al-modelo-pingpong"
class="title-slide slide level1">
<h1>Introducción al modelo <code>PingPong</code></h1>

</section>
<section id="introducción" class="slide level2">
<h2>Introducción</h2>
<p>Ahora introducimos un modelo pequeño y sencillo para identificar
algunas propiedades de liveness y luego estudiarlas.</p>
<div class="fragment">
<p>Este modelo oscila entre sólo dos estados, como en un partido de
ping-pong, de ahí su nombre.</p>
</div>
</section>
<section class="slide level2">

<p><img data-src="../img/pingpong1_automata.png" /></p>
</section>
<section class="slide level2">

<div class="columns">
<div class="column" style="width:60%;">
<p><img data-src="../img/pingpong1_automata.png" /></p>
</div><div class="column" style="width:40%;">
<p>Algunas propiedades del modelo</p>
<ol type="1">
<li class="fragment">Su ejecución no termina en ningún momento</li>
<li class="fragment">Su estado inicial es <code>ponging</code></li>
<li class="fragment">Está parametrizado por la constante
<code>LIMIT</code></li>
<li class="fragment">El modelo hace <code>ping</code> (o
<code>pong</code>) <code>LIMIT</code> veces y luego alterna.
<ul>
<li class="fragment">(esto último se hace por medio de guardas y
variables)</li>
</ul></li>
</ol>
</div>
</div>
</section>
<section id="especificación-en-event-b-variables" class="slide level2">
<h2>Especificación en Event-B (variables)</h2>
<p><img data-src="../img/pingpong2_automata.png" /></p>
</section>
<section id="especificación-en-event-b-pre--y-post-condiciones"
class="slide level2">
<h2>Especificación en Event-B (pre- y post-condiciones)</h2>
<p><img data-src="../img/pingpong_eventos.png" /></p>
</section>
<section id="identificamos-una-propiedad-de-liveness"
class="slide level2">
<h2>Identificamos una propiedad de liveness</h2>
<p>Ahora que entendemos el modelo en detalle, observamos una propiedad
interesante:</p>
<blockquote>
<p>“<strong>Siempre</strong> ocurre que, <strong>eventualmente</strong>,
el modelo se encuentra en el estado <code>pinging</code>”</p>
</blockquote>
<div class="fragment">
<p>Intuitivamente, esto es cierto porque el modelo
<strong>siempre</strong> oscila entre dos estados, de los cuales uno es
el estado <code>pinging</code>.</p>
</div>
<div class="fragment">
<p>Esta es una propiedad de <em>existencia</em>. Las siguientes
preguntas son:</p>
<ol type="1">
<li class="fragment">¿cómo formalizamos esta propiedad?</li>
<li class="fragment">¿cómo <strong>demostramos</strong> esta propiedad
para nuestro modelo? (spoiler: con esfuerzo!)</li>
<li class="fragment">¿cómo <strong>verificamos</strong> esta
propiedad?</li>
</ol>
</div>
</section></section>
<section>
<section id="hacia-una-definición-formal-de-existencia"
class="title-slide slide level1">
<h1>Hacia una definición formal de existencia</h1>

</section>
<section id="introducción-a-ltl" class="slide level2">
<h2>Introducción a LTL</h2>
<p>Para definir formalmente una propiedad de liveness es necesario
hablar de <em>tiempo</em>.</p>
<div class="fragment">
<p>Para este fin usamos lógica formal.</p>
</div>
<div class="fragment">
<p>La Lógica Temporal Lineal (LTL) es una extensión de la <em>lógica de
1er orden</em> que incluye <strong>operadores temporales</strong>.</p>
<aside class="notes">
<p>Por lo tanto, una fórmula LTL se ve muy parecida a una fórmula lógica
de 1er orden: con las conectivas lógicas que ya conocemos (AND, OR, NOT,
etc.) y variables lógicas que pueden ser TRUE o FALSE.</p>
</aside>
</div>
<div class="fragment">
<p>Los operadores temporales de LTL nos permiten expresar cosas como
<strong>siempre</strong>, <strong>después</strong>,
<strong>eventualmente</strong>, etc.</p>
</div>
</section>
<section class="slide level2">

<p>Al igual que la lógica de 1er orden, la LTL se puede analizar desde
dos puntos de vista:</p>
<div class="fragment">
<ol type="1">
<li class="fragment">La <em>sintaxis</em> (cómo se construyen las
fórmulas lógicas)</li>
<li class="fragment">La <em>semántica</em> (cuándo se satisfacen las
fórmulas)</li>
</ol>
</div>
<div class="fragment">
<p>Empezamos por la semántica.</p>
<aside class="notes">
<p>Recordemos que en lógica de 1er orden, una fórmula con variables es
satisfecha por una <em>asignación</em> de variables particular.</p>
</aside>
</div>
</section>
<section id="estructura-de-kripke-del-modelo-pingpong"
class="slide level2">
<h2>Estructura de Kripke del modelo PingPong</h2>
<p>La semántica de LTL requiere de una estructura auxiliar llamada
<strong>estructura de Kripke</strong>.</p>
<div class="fragment">
<p>La estructura de Kripke se obtiene de agregar fórmulas lógicas a una
máquina de estado.</p>
</div>
<div class="fragment">
<p>Veamos una estructura de Kripke para el modelo
<code>PingPong</code>.</p>
</div>
</section>
<section class="slide level2">

<p><img data-src="../img/pingpong3_automata.png" /></p>
<p>⇒ Definimos un conjunto de proposiciones y en base a <em>ellas</em>
definimos los estados de la máquina.</p>
<aside class="notes">
<p>Una estructura de Kripke es una máquina de estados enriquecida con
proposiciones lógicas (de 1er orden!).</p>
<p>En cada estado de la máquina tenemos en rojo <em>cuáles</em>
proposiciones son verdaderas.</p>
</aside>
</section>
<section id="traza-de-una-máquina" class="slide level2">
<h2>Traza de una máquina</h2>
<p>Con la estructura de Kripke, podemos empezar a analizar si ciertas
fórmulas LTL son verdaderas o no.</p>
<div class="fragment">
<p>Se dice que una fórmula es válida si <strong>todas</strong> las
<em>trazas</em> de la estructura de Kripke satisfacen la fórmula.</p>
</div>
<div class="fragment">
<p>⇒ Una traza es una sucesión (posiblemente infinita!) de estados.
Estos se obtienen de ejecutar la máquina <strong>respetando las
restricciones</strong>.</p>
</div>
</section>
<section id="traza-del-modelo-pingpong-limit-2" class="slide level2">
<h2>Traza del modelo PingPong (<code>LIMIT = 2</code>)</h2>
<div class="columns">
<div class="column" style="width:80%;">
<p><img data-src="../img/pingpong3_automata.png" /></p>
</div><div class="column" style="width:60%;">
<p>Para cada valor de <code>LIMIT</code>, el modelo PingPong tiene una
única traza posible. Por ejemplo:</p>
<ul>
<li class="fragment"><span
class="math inline"><em>Ω</em> = <em>s</em><sub>2</sub>, <em>s</em><sub>1</sub>, <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>1</sub>, ...</span></li>
</ul>
<p>Asociado a cada estado de la traza, se encuentra el conjunto de
proposiciones que son verdaderas para ese estado:</p>
<ul>
<li class="fragment"><span
class="math inline"><em>w</em> = {¬<em>p</em>, <em>l</em>}, {<em>p</em>, <em>m</em>}, {<em>p</em>, <em>h</em>}, {¬<em>p</em>, <em>m</em>}, ...</span></li>
</ul>
<p>(Esta sucesión se llama <em>palabra</em>)</p>
</div>
</div>
</section>
<section id="formulando-existencia" class="slide level2">
<h2>Formulando existencia</h2>
<p>Para formular nuestra propiedad de existencia, necesitamos dos
operadores temporales.</p>
<ol type="1">
<li class="fragment">Siempre (<span class="math inline">▫</span>)</li>
<li class="fragment">Eventualmente (<span
class="math inline">◊</span>)</li>
</ol>
<div class="fragment">
<p>Con estos dos, podemos formular la propiedad que deseamos:</p>
<blockquote>
<p>“<strong>Siempre</strong> ocurre que, <strong>eventualmente</strong>,
el modelo se encuentra en el estado <code>pinging</code>”</p>
</blockquote>
</div>
<div class="fragment">
<p>En LTL:</p>
<p><span class="math display">▫(◊<em>p</em>)</span></p>
</div>
</section>
<section id="verificando-la-válidez-de-la-fórmula-a-mano"
class="slide level2">
<h2>Verificando la válidez de la fórmula (a mano)</h2>
<p>Anteriormente calculamos la traza para <code>LIMIT = 2</code>:</p>
<ul>
<li><span
class="math inline"><em>Ω</em> = <em>s</em><sub>2</sub>, <em>s</em><sub>1</sub>, <em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>2</sub>, <em>s</em><sub>1</sub>, ...</span></li>
</ul>
<p>y su correpondiente palabra:</p>
<ul>
<li><span
class="math inline"><em>w</em> = {¬<em>p</em>, <em>l</em>}, {<em>p</em>, <em>m</em>}, {<em>p</em>, <em>h</em>}, {¬<em>p</em>, <em>m</em>}, ...</span></li>
</ul>
<div class="fragment">
<p>¿Cómo podemos validar que la traza satisface la fórmula:</p>
<p><span class="math display">▫(◊<em>p</em>)</span></p>
<p>?</p>
</div>
<div class="fragment">
<p>Porque:</p>
<ol type="1">
<li><span class="math inline">▫<em>p</em></span>: se satisface si
<em>p</em> es satisfecho por todas las <em>subtrazas</em>.</li>
<li><span class="math inline">◊<em>p</em></span>: se satisface si
<em>p</em> es satisfecho por alguna <em>subtraza</em>.</li>
<li><span class="math inline"><em>p</em></span>: se satisface si el
primer elemento de la traza satisface <em>p</em></li>
</ol>
</div>
</section>
<section class="slide level2">

<p><img data-src="../img/traza1.png" /></p>
</section>
<section class="slide level2">

<p><img data-src="../img/traza2.png" /></p>
</section>
<section class="slide level2">

<p><img data-src="../img/traza3.png" /></p>
</section>
<section id="otras-fórmulas" class="slide level2">
<h2>Otras fórmulas</h2>
<p>El modelo también satisface otras fórmulas LTL:</p>
<ul>
<li><span class="math inline">▫(<em>l</em> ⟹ ◊<em>h</em>)</span>
(progreso de <em>l</em> a <em>h</em>)</li>
<li><span class="math inline">▫(<em>h</em> ⟹ ◊<em>l</em>)</span>
(progreso de <em>h</em> a <em>l</em>)</li>
</ul>
<p>Si incluimos un estado final (modelo PingPongEnd).</p>
<ul>
<li><span class="math inline">◊(▫<em>f</em>))</span> (persistencia)</li>
</ul>
<p>Pero no nos detendremos analizarlas.</p>
</section>
<section id="observaciones" class="slide level2">
<h2>Observaciones</h2>
<p>Todas las propiedades de liveness se pueden expresar usando fórmulas
LTL</p>
<div class="fragment">
<p>Si una propiedad de liveness no se cumple, siempre debe existir una
traza que sirva de contraejemplo.</p>
<aside class="notes">
<p>Esto último también es cierto para propiedades de safety. La
diferencia es que en las propiedades de safety, el contraejemplo es
siempre finito y puede ser simplemente un prefijo de la traza de
ejecución completa.</p>
</aside>
</div>
</section></section>
<section>
<section id="demostración-de-existencia"
class="title-slide slide level1">
<h1>Demostración de existencia</h1>

</section>
<section id="posibilidades-y-limitaciones-de-event-b"
class="slide level2">
<h2>Posibilidades y limitaciones de Event-B</h2>
<p>Es posible demostrar varias propiedades de liveness utilizando
Event-B <a href="#/fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<div class="fragment">
<p>Sin embargo, esto se debe hacer por medio de <em>lemas
auxiliares</em>. No se puede hablar directamente de las trazas de una
máquina, lo cual complica mucho su expresión.</p>
</div>
</section>
<section id="existencia-de-p-demostración" class="slide level2">
<h2>Existencia de <span class="math inline"><em>P</em></span>
(demostración)</h2>
<p>Por medio de dos propiedades auxiliares <a href="#/fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>:</p>
<ol type="1">
<li><strong>Convergencia en <span
class="math inline">¬<em>P</em></span></strong></li>
<li><strong><span class="math inline">¬<em>P</em></span> es libre de
deadlocks</strong></li>
</ol>
<div class="fragment">
<figure>
<img data-src="../img/son_hoang_2014_existence_proof_rule.png"
alt="Existencia - Regla de inferencia" />
<figcaption aria-hidden="true">Existencia - Regla de
inferencia</figcaption>
</figure>
</div>
<div class="fragment">
<p>Intuición:</p>
<ol type="1">
<li><span class="math inline">¬<em>P</em></span> debe transicionar a
otro estado eventualmente, sino <span
class="math inline"><em>P</em></span> sería imposible.</li>
<li><span class="math inline">¬<em>P</em></span> debe ser deadlock-free,
o de otra forma sería imposible que <span
class="math inline"><em>P</em></span> sea cierto.</li>
</ol>
</div>
</section>
<section class="slide level2">

<p>La demostración de existencia del estado <code>pinging</code> está
hecha para el modelo PingPong, pero la omitimos por cuestiones de tiempo
:) .</p>
</section></section>
<section>
<section id="verificación-en-prob" class="title-slide slide level1">
<h1>Verificación en ProB</h1>

</section>
<section id="model-checking-al-rescate" class="slide level2">
<h2>Model checking al rescate</h2>
<p>Vimos que es posible verificar propiedades de existencia triviales a
mano.</p>
<div class="fragment">
<p>Y también es posible demostrarlas en Event-B, aunque con bastante
esfuerzo.</p>
</div>
<div class="fragment">
<p>El model checking nos ayuda a verificar modelos de mayor tamaño</p>
</div>
</section>
<section id="model-check-i" class="slide level2">
<h2>“Model check” (I)</h2>
<p>Esta funcionalidad explora lo máximo posible el espacio de estados
del modelo para encontrar <em>violaciones de invariantes/teoremas</em> y
<em>deadlocks</em>.</p>
<p>Es útil para verificar que el modelo cumple con las variantes
<strong>antes de demostrarlo</strong>.</p>
</section>
<section id="model-check-ii" class="slide level2">
<h2>“Model check” (II)</h2>
<p>Hay dos casos donde el model check no es exhaustivo:</p>
<ul>
<li><strong>No se exploró el espacio de estados completo</strong></li>
<li><strong>No se exploraron todos los eventos posibles</strong></li>
</ul>
<p>Ambos se pueden remediar aumentando los valores de las constantes
<code>MAX_INITIALIZATIONS</code> y <code>MAX_OPERATIONS</code> y
<strong>acotando las constantes del modelo</strong> (fundamental).</p>
<figure>
<img data-src="../img/screenshot_prob_animation_settings.png"
alt="ProB - Opciones de animación" />
<figcaption aria-hidden="true">ProB - Opciones de animación</figcaption>
</figure>
</section>
<section id="model-check-iii" class="slide level2">
<h2>“Model check” (III)</h2>
<p>El <em>model checking</em> nos permite <strong>sólo
verificar</strong>, no demostrar.</p>
<p>En el mejor de los casos (cuando el chequeo es exhaustivo), nos
permite <strong>demostrar</strong> las propiedades deseadas en un modelo
más pequeño que el “real”.</p>
</section>
<section id="ltl-checking-i" class="slide level2">
<h2>LTL checking (I)</h2>
<p>Esta funcionalidad nos permite escribir fórmulas LTL que son
verificadas por ProB.</p>
<p>ProB soporta todos los operadores temporales e incluso algunos
operadores específicos a B/Event-B que facilitan la escritura de
propiedades útiles.</p>
</section>
<section id="ltl-checking-ii" class="slide level2">
<h2>LTL checking (II)</h2>
<p>Las propiedades de liveness se pueden escribir del siguiente
modo:</p>
<pre><code>G F ({is_pinging = 1}))
G F ({is_pinging = 0}))
F G ({runs_counter = RUNS_LIMIT})
G (e(ping) =&gt; F (e(pong)))</code></pre>
<p>Donde <code>e(&lt;evento&gt;)</code> es la <em>guarda del evento en
cuestión</em> (i.e: el evento está activado).</p>
</section></section>
<section>
<section id="bibliografía" class="title-slide slide level1">
<h1>Bibliografía</h1>

</section>
<section id="bibliografía-1" class="slide level2">
<h2>Bibliografía</h2>
</section></section>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>B. Alpern y F. B. Schneider, «Defining liveness»,
Information Processing Letters, vol. 21, n.º 4, pp. 181-185, oct. 1985,
doi: 10.1016/0020-0190(85)90056-0.<a href="#/fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>T. S. Hoang y J.-R. Abrial, «Reasoning about Liveness
Properties in Event-B», en Formal Methods and Software Engineering,
vol. 6991, S. Qin y Z. Qiu, Eds., en Lecture Notes in Computer Science,
vol. 6991. , Berlin, Heidelberg: Springer Berlin Heidelberg, 2011,
pp. 456-471. doi: 10.1007/978-3-642-24559-6_31.<a href="#/fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>T. S. Hoang y J.-R. Abrial, «Reasoning about Liveness
Properties in Event-B», en Formal Methods and Software Engineering,
vol. 6991, S. Qin y Z. Qiu, Eds., en Lecture Notes in Computer Science,
vol. 6991. , Berlin, Heidelberg: Springer Berlin Heidelberg, 2011,
pp. 456-471. doi: 10.1007/978-3-642-24559-6_31.<a href="#/fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4/plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        width: 1920,

        height: 1200,
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>

  <script>
  var ws = new WebSocket('ws://localhost:8097/');

  ws.onmessage = function(event) {
    console.log('Re-compiled sources: ' + event.data);
    console.log('Reloading web page');
    window.location.reload();
  };
  </script>

    </body>
</html>
